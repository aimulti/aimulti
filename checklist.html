<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>마케팅 30일 체크리스트</title>
<style>
  /* 모든 요소에 box-sizing 적용 */
  * {
    box-sizing: border-box;
  }

  /* 기본 스타일 */
body {
  margin: 0;
  font-family: 'Segoe UI', Arial, sans-serif;
  background: #f4f7fa;
  padding-top: 112px; /* 타이틀(56px) + 프로그레스바(56px) */
}

#header-title-fixed {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  background: white;
  z-index: 9999;
  border-bottom: 1px solid #e5e7eb;
  box-shadow: 0 2px 6px rgba(0,0,0,0.04);
  text-align: center;
  padding: 14px 0 8px 0;
  height: 56px;
  display: flex;
  align-items: center;
  justify-content: space-between;
}
#header-title-fixed h1 {
  font-size: 1.7em;
  color: #2c3e50;
  margin: 0 0 0 24px;
  font-weight: bold;
  letter-spacing: 0.02em;
  display: block;
  opacity: 1;
}

/* 앱 제목 (수정 가능) */
#app-title {
  font-size: 1.7em;
  color: #2c3e50;
  margin: 0 0 0 24px;
  font-weight: bold;
  letter-spacing: 0.02em;
  display: block;
  opacity: 1;
  cursor: text; /* 텍스트 편집 커서 */
  outline: none; /* 포커스 시 아웃라인 제거 */
  min-width: 150px; /* 편집 시 최소 너비 */
  padding: 2px 5px;
  border-radius: 4px;
}
#app-title:focus {
  background-color: #e0f2f7;
  box-shadow: 0 0 0 2px rgba(16,185,129,0.3);
}


.download-btn, .header-action-btn { /* 일반 버튼 스타일 통일 */
  background: none !important;
  border: none !important;
  box-shadow: none !important;
  outline: none !important;
  color: #10b981;
  width: auto;
  height: auto;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.7em;
  cursor: pointer;
  padding: 0 4px;
  border-radius: 0 !important;
  transition: color 0.2s;
}
.download-btn:hover, .header-action-btn:hover {
  color: #059669;
  background: none !important;
  border: none !important;
  box-shadow: none !important;
}

#share-buttons {
  Display: flex;
  Gap: 7px;
  Margin-right: 18px;
}

.share-btn {
background: none !important;
  border: none !important;
  box-shadow: none !important;
  outline: none !important;
  color: #10b981;
  width: auto;
  height: auto;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.7em;
  cursor: pointer;
  padding: 0 4px;
  border-radius: 0 !important;
}
.share-btn:hover {
  background: none !important;
  color: #059669;
  border: none !important;
  box-shadow: none !important;
}
#progress-container {
  position: fixed;
  top: 56px;
  left: 0;
  width: 100%;
  background-color: white;
  color: #2d6a4f;
  font-weight: bold;
  font-size: 1.1em;
  padding: 10px 16px 10px 16px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.08);
  z-index: 9998;
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid #e5e7eb;
  height: 56px;
}
#progress-text {
  flex: 0 0 auto;
}
#progress-bar-bg {
  flex: 1 1 auto;
  background-color: #d1fae5;
  border-radius: 12px;
  height: 18px;
  margin-left: 15px;
  overflow: hidden;
  box-shadow: inset 0 0 5px rgba(0,0,0,0.1);
}
#progress-bar-fill {
  height: 100%;
  background: linear-gradient(90deg, #34d399, #059669);
  width: 0%;
  transition: width 0.3s ease;
  border-radius: 12px 0 0 12px;
}



  /* 오른쪽 하단 고정 원형 전체 진행률 */
  #circular-progress {
    position: relative;
    bottom: 20px;
    right: 20px;
    width: 100px; /* 크기 증가 */
    height: 100px; /* 크기 증가 */
    z-index: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    background: white;
    border-radius: 50%;
    box-shadow: 0 0 10px rgba(16,185,129,0.4);
    pointer-events: none;
    transition: none;
  }

#circular-progress-wrapper {
  position: fixed;
  right: 0px;
  bottom: 0px;
  z-index: 2000;
  width: 100px;
  height: 100px;
  display: block;
  align-items: center;
  justify-content: center;
}

/* 동그란 원 */
#circular-progress {
  position: relative;
  width: 100px;
  height: 100px;
  z-index: 1;
}

/* 맨 위로 버튼을 원 위에 띄우기 */
#scroll-to-top-btn {
  position: absolute;
  right: -10px;
  /* 중앙이 아니라, 원의 위쪽에 붙이기: */
  top: -80px; /* 버튼 크기/원 크기에 따라 조정(56px 버튼일 때 -28px이 위에 딱 붙음) */
  transform: translate(-50%, 0);
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: linear-gradient(135deg, #34d399 60%, #059669 100%);
  color: white;
  border: none;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 12px rgba(16,185,129,0.35);
  cursor: pointer;
  z-index: 2;
  transition: background 0.2s, box-shadow 0.2s, opacity 0.3s;
  font-size: 1.5em;
  opacity: 0.93;
  pointer-events: auto;
  overflow: hidden;
}

#scroll-to-top-btn .material-icons {
  font-size: 2em;
  display: block;
  margin: 0;
  line-height: 1;
  width: 1em;
  height: 1em;
  text-align: center;
  vertical-align: middle;
}

#scroll-to-top-btn.hide {
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s;
}
#scroll-to-top-btn:hover {
  background: linear-gradient(135deg, #059669 60%, #34d399 100%);
  box-shadow: 0 8px 18px rgba(16,185,129,0.48);
  opacity: 1;
}

/* 모바일 대응 */
@media (max-width: 768px) {
  #circular-progress-wrapper {
    right: 0px;
    bottom: 110px;
    width: 70px;
    height: 70px;
  }
  #circular-progress {
    width: 70px;
    height: 70px;
  }
  #circular-progress svg {
    width: 70px;
    height: 70px;
  }
  #scroll-to-top-btn {
    width: 30px;
    height: 30px;
    font-size: 1.1em;
    top: -70px; /* 모바일에서 버튼이 원 위에 잘 붙도록 조정 */
    Right: 0px;
  }
}

  .circular-svg {
    width: 100%; /* 부모 div에 맞춰 조절 */
    height: 100; /* 부모 div에 맞춰 조절 */
    Display: block;
  }
  .circular-bg {
    stroke: #ffffff;
    stroke-width: 10; /* 선 굵기 증가 */
    fill: none;
  }
  .circular-fg {
    stroke: url(#circular-gradient);
    stroke-width: 10; /* 선 굵기 증가 */
    /* stroke-linecap: round;  <-- 이 부분을 제거합니다. */
    transition: stroke-dashoffset 0.5s cubic-bezier(.4,2,.6,1);
    transform: rotate(-90deg);
    transform-origin: 50% 50%; /* 중앙 기준으로 회전 */
    fill: none;
  }
  .circular-text {
    font-size: 1.8em; /* 글씨 크기 증가 */
    fill: #10b981;
    font-weight: bold;
    font-family: 'Arial', sans-serif;
    pointer-events: none;
    user-select: none;
    /* SVG 내부 텍스트 중앙 정렬 */
    dominant-baseline: middle;
    alignment-baseline: middle;
    text-anchor: middle;
  }
  .circular-label {
    font-size: 1.2em; /* 글씨 크기 증가 */
    fill: #10b981;
    font-family: 'Arial', sans-serif;
    font-weight: bold;
    pointer-events: none;
    user-select: none;
    /* SVG 내부 텍스트 중앙 정렬 */
    dominant-baseline: middle;
    alignment-baseline: middle;
    text-anchor: middle;
  }
  h1 { display: none; } /* 페이지 제목은 고정 헤더에만 표시 */

  /* 체크리스트 컨테이너 - 가로 스크롤 및 드래그 */
  #checklist-wrapper {
    position: relative; /* 화살표 버튼 위치 지정을 위해 추가 */
    padding-bottom: 20px; /* 스크롤바 공간 확보 */
  }

  #checklist {
    display: flex; /* 플렉스 박스 */
    overflow-x: auto; /* 가로 스크롤 가능 */
    scroll-snap-type: x mandatory; /* 카드 스냅 효과 */
    -webkit-overflow-scrolling: touch; /* iOS 부드러운 스크롤 */
    scrollbar-width: thin; /* Firefox 스크롤바 */
    scrollbar-color: #34d399 #e5e7eb; /* Firefox 스크롤바 색상 */
    cursor: grab; /* 드래그 가능한 커서 */
  }
  #checklist.grabbing {
    cursor: grabbing; /* 드래그 중 커서 */
  }
  #checklist::-webkit-scrollbar {
    height: 8px;
  }
  #checklist::-webkit-scrollbar-track {
    background: #e5e7eb;
    border-radius: 10px;
  }
  #checklist::-webkit-scrollbar-thumb {
    background: #34d399;
    border-radius: 10px;
  }
  #checklist::-webkit-scrollbar-thumb:hover {
    background: #059669;
  }

  /* 카테고리 카드 스타일 */
  .category-box {
    background: #fff;
    border-radius: 12px;
    padding: 20px;
    margin-right: 20px; /* 카드 간 간격 */
    box-shadow: 0 4px 15px rgba(0,0,0,0.08);
    border: 1px solid #e0e0e0;
    min-width: 320px; /* PC 기본 카드 너비 */
    flex: 0 0 auto; /* 플렉스 아이템이 축소되지 않도록 설정 */
    scroll-snap-align: start; /* 카드 시작 지점에 스냅 */
    max-width: 400px; /* PC에서 너무 넓어지지 않도록 최대 너비 설정 */
    display: flex; /* 내부 요소 정렬 */
    flex-direction: column; /* 세로 정렬 */
  }

  /* 마지막 카드 margin-right 제거 */
  #checklist > .category-box:last-child {
    margin-right: 0;
  }

  .category-box h2 {
    color: #1a4d2e;
    font-size: 1.6em;
    margin-top: 0;
    margin-bottom: 15px;
    border-bottom: 2px solid #a7d9b5;
    padding-bottom: 8px;
    display: flex;
    align-items: center;
    font-weight: bold;
    justify-content: space-between; /* 아이콘과 제목 간격 조정 */
  }
  .category-box h2 .material-icons { /* Material Icons 스타일 */
    margin-right: 8px;
    color: #2d6a4f;
    font-size: 1.2em;
  }

  .category-actions {
    display: flex;
    align-items: center;
    gap: 5px;
  }
  .edit-category-btn, .delete-category-btn {
    color: #10b981;
    cursor: pointer;
    font-size: 1em;
    margin-left: 5px; /* 아이콘 사이 간격 */
    transition: color 0.2s;
  }
  .edit-category-btn:hover {
    color: #059669;
  }
  .delete-category-btn {
    color: #e63946;
  }
  .delete-category-btn:hover {
    color: #d62828;
  }


  .day-section {
    background: #fdfdfd;
    border-radius: 8px;
    padding: 15px 20px;
    margin-bottom: 12px;
    box-shadow: 0 1px 5px rgba(0,0,0,0.05);
    position: relative;
    border: 1px solid #edf2f7;
  }
  .day-section h3 {
    color: #34495e;
    font-size: 1.1em;
    margin-top: 0;
    margin-bottom: 8px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-weight: 600;
  }
  .day-section h3 .day-actions { /* Day 액션 버튼들을 위한 컨테이너 */
    display: flex;
    align-items: center;
    gap: 5px;
  }
  .day-section h3 .edit-day-btn { /* Day 수정 버튼 */
    color: #10b981;
    cursor: pointer;
    font-size: 1em;
    transition: color 0.2s;
  }
  .day-section h3 .edit-day-btn:hover {
    color: #059669;
  }
  .day-section h3 .delete-day-btn {
    color: #e63946;
    cursor: pointer;
    font-size: 1em;
    transition: color 0.2s;
  }
  .day-section h3 .delete-day-btn:hover {
    color: #d62828;
  }
  .day-progress-text {
    font-size: 0.9em;
    color: #2d6a4f;
    font-weight: 600;
    min-width: 40px;
    text-align: right;
    margin-left: 10px;
  }
  .day-progress-bar-bg {
    width: 100%;
    height: 10px;
    background-color: transparent;
    border: 1.5px solid #d1fae5;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: none;
    margin: 6px 0 10px 0;
  }
  .day-progress-bar-fill {
    height: 100%;
    background: linear-gradient(90deg, #6ee7b7, #10b981);
    width: 0%;
    transition: width 0.3s ease;
    border-radius: 10px 0 0 10px;
  }
  ul {
    padding-left: 0; /* 체크박스 정렬을 위해 0px로 설정 */
    margin: 0;
    list-style: none; /* 기본 리스트 스타일 제거 */
  }
  li {
    margin-bottom: 8px;
    font-size: 0.95em;
    transition: all 0.2s ease-in-out;
    display: flex; /* 체크박스와 텍스트를 한 줄에 정렬 */
    align-items: center;
    justify-content: flex-start;
    position: relative; /* 버튼 위치 지정을 위해 */
    padding-left: 28px; /* +.체크박스 공간 확보 */
  }
  li:hover {
    background-color: #f0f8ff;
    border-radius: 6px;
  }

  /* 태스크 텍스트와 액션 버튼을 감싸는 div */
  .task-content-wrapper {
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-grow: 1; /* 남은 공간 모두 차지 */
  }

  /* 커스텀 체크박스 스타일 */
  input[type="checkbox"] {
    opacity: 0; /* 기본 체크박스 숨기기 */
    position: absolute;
    z-index: -1; /* 다른 요소에 가려지지 않도록 */
  }
  input[type="checkbox"] + span::before { /* 체크박스 대신 표시될 요소 */
    content: '';
    display: inline-block;
    width: 1.2em;
    height: 1.2em;
    flex-shrink: 0; /* 크기 고정 */
    flex-grow: 0;
    border: 2px solid #ccc;
    border-radius: 4px;
    margin-right: 0.5em;
    vertical-align: middle;
    transition: background-color 0.2s, border-color 0.2s;
    background-color: #f0f0f0;
  }
  input[type="checkbox"]:checked + span::before {
    background-color: #34d399; /* 체크 시 배경색 */
    border-color: #34d399; /* 체크 시 테두리색 */
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 16 16' fill='white' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M12.207 4.793a1 1 0 011.414 0l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414l3.293 3.293 7.293-7.293a1 1 0 010 1.414z'/%3E%3C/svg%3E"); /* 체크 아이콘 (흰색) */
    background-repeat: no-repeat;
    background-position: center;
    background-size: 80%;
  }
  input[type="checkbox"]:focus + span::before {
    box_shadow: 0 0 0 3px rgba(52, 211, 153, 0.5); /* 포커스 시 아웃라인 */
  }

  label {
    display: flex; /* 텍스트와 체크박스를 한 줄에 정렬 */
    align-items: center;
    cursor: pointer;
    padding: 2px 0;
    flex-grow: 1; /* 라벨이 가능한 공간을 모두 차지하도록 */
  }
  label:hover {
    background-color: #f0f8ff;
    border-radius: 6px;
    padding: 2px 4px;
  }
  .checked {
    text-decoration: line-through;
    color: #aaa;
  }

  .edit-task-input {
    width: calc(100% - 2em); /* 체크박스 공간 제외 */
    padding: 4px 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 0.95em;
    margin-left: 1.7em; /* 체크박스 공간과 동일하게 */
  }

  .task-actions {
    display: flex;
    align-items: center;
    gap: 5px; /* 버튼 간격 */
    flex-shrink: 0; /* 버튼이 줄바꿈되지 않도록 */
  }

  .edit-task-btn, .delete-task-btn {
    color: #10b981; /* 수정 버튼 색상 */
    cursor: pointer;
    font-size: 1.2em;
    transition: color 0.2s;
  }
  .edit-task-btn:hover {
    color: #059669;
  }
  .delete-task-btn {
    color: #e63946; /* 삭제 버튼 색상 */
  }
  .delete-task-btn:hover {
    color: #d62828;
  }

  /* 각 태스크 항목 내에 추가 버튼 (SVG로 변경됨) */
  .add-task-inline-btn {
    position: absolute;
    left: 0; /* LI의 왼쪽 가장자리에 배치 */
    top: 50%;
    transform: translateY(-50%);
    background: none !important; /* 배경 없음 */
    border: none !important;
    border-radius: 0 !important; /* 원형 아님 */
    width: 24px !important; /* SVG 크기에 맞춤 */
    height: 24px !important; /* SVG 크기에 맞춤 */
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    opacity: 1; /* 항상 표시 */
    transition: all 0.2s; /* 색상 전환 효과 */
    padding: 0 !important; /* 패딩 없음 */
    margin-right: 5px; /* 체크박스와 간격 */
    box-shadow: none !important; /* 그림자 제거 */
  }
  .add-task-inline-btn .add-icon {
    width: 100%;
    height: 100%;
  }
  .add-task-inline-btn:hover .add-icon path {
    stroke: url(#addTaskGradientHover); /* 호버 시 그라데이션 변경 */
  }


  /* Day에 태스크가 하나도 없을 경우의 '첫 태스크 추가' 버튼 */
  .add-first-task-btn {
    background: transparent; /* 바탕색 없음 */
    padding: 8px 12px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 0.85em;
    width: 100%; /* 너비 꽉 채우도록 */
    text-align: center;
    transition: all 0.2s; /* 배경, 테두리, 텍스트 색상 변화에 대비 */
    margin-top: 10px; /* Day progress bar 아래 여백 */

    /* 그라데이션 테두리 */
    border: 2px solid;
    border-image: linear-gradient(135deg, #34d399, #059669) 1; /* 테두리에 그라데이션 적용 */
    border-image-slice: 1; /* 테두리 이미지가 테두리를 꽉 채우도록 */

    /* 텍스트/플러스 아이콘 그라데이션 색상 */
    color: transparent; /* 텍스트 자체는 투명하게 */
    -webkit-background-clip: text; /* 텍스트에 배경 클립 적용 */
    background-clip: text;
    background-image: linear-gradient(135deg, #34d399 60%, #059669 100%); /* 텍스트에 그라데이션 배경 */
    -webkit-text-fill-color: transparent; /* WebKit 브라우저용 텍스트 채우기 색상 투명하게 */
  }
  .add-first-task-btn:hover {
    /* 호버 시 그라데이션 반전 또는 다른 색상으로 */
    border-image: linear-gradient(135deg, #059669, #34d399) 1;
    background-image: linear-gradient(135deg, #059669 60%, #34d399 100%);
  }


  .add-day-btn { /* Category Box 내 Day 추가 버튼 */
    background: transparent; /* 투명 배경 */
    color: transparent; /* 텍스트 색상 투명 */
    padding: 8px 12px;
    border: 2px solid #34d399; /* 테두리 색상을 그라데이션 시작 색상으로 고정 */
    border-radius: 9999px; /* 완전히 둥글게 처리 */
    cursor: pointer;
    margin-top: 15px;
    font-size: 0.85em;
    width: 100%; /* 너비를 꽉 채우도록 */
    text-align: center;
    transition: all 0.2s; /* 모든 속성 변화에 대비 */
    box-shadow: none; /* 그림자 제거 */
    
    /* 텍스트 그라데이션 */
    -webkit-background-clip: text;
    background-clip: text;
    background-image: linear-gradient(135deg, #34d399 60%, #059669 100%);
    -webkit-text-fill-color: transparent;
  }
  .add-day-btn:hover {
    background: linear-gradient(135deg, #059669, #34d399); /* 호버 시 배경 그라데이션 */
    border-color: #059669; /* 호버 시 테두리 색상 변경 */
    color: white; /* 텍스트를 흰색으로 */
    -webkit-text-fill-color: white; /* 웹킷 브라우저용 텍스트 흰색 */
    background-clip: border-box; /* 배경 클립을 border-box로 설정하여 전체 버튼에 적용 */
    -webkit-background-clip: border-box;
    box-shadow: none; /* 호버 시에도 그림자 제거 */
  }


  /* 화살표 버튼 */
  .scroll-button {
    Flex: none !important;
    Align-self: center !important;
    position: fixed;
    top: 50%;
    transform: translateY(-50%); /* 버튼 자체를 세로 중앙으로 정렬 */
    background-color: transparent;
    color: #10b981;
    border: 2.5px solid #10b981;
    border-radius: 50% !important;
    width: 36px !important;
    height: 36px !important;
    Min-width: 36px !important;
    Min-height: 36px !important;
    Max-width: 36px !important;
    Max-height: 36px !important;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 1.5em;
    font-weight: bold;
    z-index: 10; /* 고정 헤더보다 낮은 z-index로 겹치지 않도록 */
    transition: background-color 0.2s, opacity 0.2s;
    opacity: 0.85;
    box-shadow: 0 2px 8px rgba(16, 185, 129, 0.15);
    Box-sizing: border-box !important;
    Background-clip: border-box;
    Padding: 0 !important;
    Margin: 0 !important;
  }
  .scroll-button:hover {
    background: linear-gradient(135deg, #34d399 60%, #059669 100%);
    Border-color: #059669;
    opacity: 1;
  }
  .scroll-button:hover.left {
  -webkit-text-fill-color: #fff;
  color: #fff;
  background-clip: border-box;
  -webkit-background-clip: border-box;
  background-image: linear-gradient(135deg, #34d399 60%, #059669 100%);
}
  .scroll-button:hover.right {
  -webkit-text-fill-color: #fff;
  color: #fff;
  background-clip: border-box;
  -webkit-background-clip: border-box;
  background-image: linear-gradient(135deg, #34d399 60%, #059669 100%);
}
  .scroll-button.left {
    Background: transparent;
    Background-clip: border-box;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    Background-image: linear-gradient(135deg, #34d399 60%, #059669 100%);
    Color: #10b981;
    left: 10px; /* 화면 좌측에서 10px 떨어짐 */
  }
  .scroll-button.right {
    Background: transparent;
    Background-clip: border-box;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    Background-image: linear-gradient(135deg, #34d399 60%, #059669 100%);
    Color: #10b981;
    right: 10px; /* 화면 우측에서 10px 떨어짐 */
  }
  .scroll-button.hidden {
    display: none; /* 필요 없을 때 숨김 */
  }


  /* 하단 버튼 */
  #buttons {
    text-align: center;
    margin: 20px 0 40px 0;
    display: flex; /* 버튼을 가로로 정렬하기 위해 flexbox 사용 */
    justify-content: center; /* 가운데 정렬 */
    flex-wrap: wrap; /* 작은 화면에서 줄바꿈 허용 */
    gap: 10px; /* 버튼 간격 */
  }
  button {
    display: inline-block;
    padding: 10px 20px;
    font-size: 0.9em;
    border: none;
    border-radius: 25px;
    cursor: pointer;
    color: white;
    transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
    user-select: none;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  }
  #reset-btn { background-color: #e63946; }
  #reset-btn:hover { background-color: #d62828; box-shadow: 0 4px 8px rgba(230,57,70,0.3); }
  #print-pdf-btn { background-color: #1d3557; }
  #print-pdf-btn:hover { background-color: #16315c; box-shadow: 0 4px 8px rgba(29,53,87,0.3); }
  #show-result-btn { background-color: #38a169; }
  #show-result-btn:hover { background-color: #276749; box-shadow: 0 4px 8px rgba(56,161,105,0.3); }
  #print-result-btn { background-color: #ffb703; color: #22223b; }
  #print-result-btn:hover { background-color: #e09f3e; color: #22223b; box-shadow: 0 4px 8px rgba(255,183,3,0.3); }

  /* 진단 결과 영역 */
  #diagnosis-result {
    background: white;
    border-radius: 10px;
    padding: 15px 20px;
    box-shadow: 0 1px 5px rgba(0,0,0,0.1);
    max-width: 900px;
    margin: 0 auto 40px auto;
    position: relative;
    border: 1px solid #e0e0e0;
  }
  #diagnosis-result h3 {
    margin-top: 0;
    color: #2d6a4f;
    font-size: 1.3em;
    border-bottom: 1px solid #eee;
    padding-bottom: 10px;
  }
  #diagnosis-result ul {
    max-height: 300px;
    overflow-y: auto;
    padding-left: 20px;
  }
  #diagnosis-result ul li {
    font-size: 0.9em;
    margin-bottom: 8px;
    line-height: 1.4;
  }
  #print-result-btn {
    position: absolute;
    top: 15px;
    right: 20px;
    z-index: 10;
  }

  /* 커스텀 모달 스타일 */
  .custom-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10000;
  }
  .custom-modal-content {
    background: white;
    padding: 25px;
    border-radius: 10px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    max-width: 400px;
    width: 90%;
    text-align: center;
    font-family: 'Segoe UI', Arial, sans-serif;
    color: #333;
  }
  .custom-modal-content p {
    margin-bottom: 20px;
    font-size: 1.1em;
  }
  .custom-modal-content input[type="text"] {
    width: calc(100% - 20px);
    padding: 10px;
    margin-bottom: 15px;
    border: 1px solid #ccc;
    border-radius: 5px;
    font-size: 1em;
  }
  .custom-modal-content button {
    padding: 10px 20px;
    margin: 0 8px;
    border: none;
    border-radius: 20px;
    cursor: pointer;
    font-size: 0.95em;
    transition: background-color 0.2s;
  }
  .custom-modal-content .modal-confirm-btn {
    background-color: #007bff;
    color: white;
  }
  .custom-modal-content .modal-confirm-btn:hover {
    background-color: #0056b3;
  }
  .custom-modal-content .modal-cancel-btn {
    background-color: #6c757d;
    color: white;
  }
  .custom-modal-content .modal-cancel-btn:hover {
    background-color: #5a6268;
  }

  /* 미디어 쿼리: 모바일 최적화 */
  @media (max-width: 768px) {
    body {
      padding: 10px;
      padding-top: 150px; /* 모바일 헤더 높이 고려 */
    }
   #header-title-fixed {
      display: flex !important;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background: white;
      z-index: 9999;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      border-bottom: 1px solid #e5e7eb;
    }
    #header-title-fixed h1 {
      display: block !important; 
      color: #2c3e50 !important;
      Margin-left: 10px;
      Font-size: 1.2em; 
      opacity: 1 !important;
    }
    #app-title {
        font-size: 1.2em;
        margin: 0 0 0 10px;
        min-width: unset;
        padding: 0;
    }
      #share-buttons {
    gap: 3px;
    margin-right: 6px;
  }
  .share-btn, .header-action-btn, .download-btn {
    width: 28px;
    height: 28px;
    font-size: 1em;
  }
    #progress-container {
      font-size: 0.9em;
      padding: 8px 15px 8px 15px;
      margin-bottom: 15px; /* 모바일에서도 간격 유지 */
    }
    /* 모바일에서 카드 하나씩 보이도록 */
    #checklist-wrapper {
        padding-left: 10px;
        padding-right: 10px;
    }
    .category-box {
      margin-right: 15px;
      min-width: calc(100% - 30px); /* 화면 너비에 맞춰 카드 하나씩 보이도록 (좌우 패딩 및 스크롤바 영역) */
      max-width: none; /* 모바일에서는 최대 너비 제한 해제 */
    }
    .category-box h2 {
      font-size: 1.4em;
      margin-bottom: 12px;
    }
    .day-section {
      padding: 12px 15px;
      margin-bottom: 10px;
    }
    .day-section h3 {
      font-size: 1em;
      margin-bottom: 6px;
    }
    #diagnosis-result {
      max-width: 100%;
    }
    #print-result-btn {
      position: static; /* 모바일에서는 정적으로 배치 */
      display: block;
      margin: 10px auto 0 auto;
    }
    /* 원형 진행률 크기 및 글씨 조절 (모바일) */
    #circular-progress {
      width: 80px;
      height: 80px;
      bottom: 15px;
      right: 15px;
    }
    .circular-svg {
      width: 80px;
      height: 80px;
    }
    .circular-fg {
        transform-origin: 50% 50%; /* 중앙 기준으로 회전 */
        stroke-width: 8;
    }
    .circular-bg {
        stroke-width: 8;
    }
    .circular-text { font-size: 1.3em; }
    .circular-label { font-size: 1.1em; }
    button {
      padding: 8px 15px;
      font-size: 0.85em;
    }
    /* 모바일에서 화살표 버튼 위치 조정 */
    .scroll-button {
       .scroll-button {
    width: 28px;
    height: 28px;
    min-width: 28px;
    min-height: 28px;
    max-width: 28px;
    max-height: 28px;
    font-size: 1.1em;
    border-width: 2px;
    }
    #checklist-wrapper .scroll-button.left { left: 5px; }
    #checklist-wrapper .scroll-button.right { right: 5px; }
  }

  /* 인쇄 스타일 */
  @media print {
    body {
      background: white;
      color: black;
      padding-top: 0; /* 인쇄 시 상단 패딩 제거 */
    }
    /* 인쇄 시 고정 헤더, 진행률 바, 버튼, 원형 진행률 숨김 */
    #header-title-fixed, #progress-container, #buttons, #circular-progress, h1, .scroll-button {
      display: none !important;
    }
    /* 인쇄 시 체크리스트 세로로 정렬 */
    #checklist-wrapper {
        margin-top: 0 !important;
        padding: 0 !important;
    }
    #checklist {
      display: block !important;
      overflow-x: visible !important; /* 가로 스크롤 숨김 */
      flex-wrap: wrap; /* 내용이 넘치면 다음 줄로 */
      padding: 0 !important;
      cursor: default; /* 인쇄 시 드래그 커서 제거 */
    }
    .category-box {
      box-shadow: none;
      border-radius: 0;
      border: 1px solid #ccc; /* 인쇄 시에도 테두리 유지 */
      page-break-inside: avoid; /* 박스 안 내용이 페이지를 넘어가지 않도록 */
      margin-right: 0; /* 가로 간격 제거 */
      margin-bottom: 10px; /* 세로 간격 유지 */
      min-width: auto !important; /* 최소 너비 제한 해제 */
      max-width: none !important; /* 최대 너비 제한 해제 */
      width: 100%; /* 전체 너비 사용 */
    }
    .category-box h2 {
      border-bottom: 1px solid #ccc; /* 인쇄 시에도 테두리 유지 */
      font-size: 1.4em;
    }
    .day-section {
      box-shadow: none;
      border-radius: 0;
      page-break-inside: avoid;
      border: none; /* day-section 내부 테두리 제거 */
      padding: 5px 0; /* 내부 패딩 조절 */
    }
    /* 인쇄 시 체크박스 및 레이블 스타일 조정 */
    input[type="checkbox"] + span::before {
      background-color: #f0f0f0 !important; /* 인쇄 시 배경색 유지 */
      border-color: #ccc !important; /* 인쇄 시 테두리색 유지 */
    }
    input[type="checkbox"]:checked + span::before {
      background-color: #34d399 !important; /* 체크 시 배경색 */
      border-color: #34d399 !important; /* 체크 시 테두리색 */
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 16 16' fill='black' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M12.207 4.793a1 1 0 011.414 0l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414l3.293 3.293 7.293-7.293a1 1 0 010 1.414z'/%3E%3C/svg%3E"); /* 체크 아이콘 (검정색) */
    }
    label:hover {
      transform: none !important;
      background-color: transparent !important;
      padding: 0 !important;
    }
    label {
      cursor: default !important;
    }
    /* 진단 결과만 인쇄 시 스타일 */
    body.printing-result *:not(#diagnosis-result):not(#diagnosis-result *) {
      display: none !important;
    }
    #diagnosis-result {
      display: block !important;
      position: static !important;
      box-shadow: none !important;
      border-radius: 0 !important;
      margin: 0 !important;
      padding: 0 !important;
      max-width: 100% !important;
      border: none !important;
    }
    #diagnosis-result h3 {
      border-bottom: none !important;
      padding-bottom: 0 !important;
      font-size: 1.2em;
    }
    #print-result-btn {
      display: none !important;
    }


#scroll-to-top-btn {
    position: fixed;
    right: 40px;
    bottom: 135px; /* 원형 진행률(#circular-progress) 위에 적당히 위치 */
    width: 56px;
    height: 56px;
    border-radius: 50%;
    background: linear-gradient(135deg, #34d399 60%, #059669 100%);
    color: white;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(16,185,129,0.35);
    cursor: pointer;
    z-index: 2100;
    transition: background 0.2s, box-shadow 0.2s, opacity 0.3s;
    font-size: 2em;
    opacity: 0.93;
  }
  #scroll-to-top-btn:hover {
    background: linear-gradient(135deg, #059669 60%, #34d399 100%);
    box-shadow: 0 8px 18px rgba(16,185,129,0.48);
    opacity: 1;
  }
  #scroll-to-top-btn.hide {
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s;
  }
  /* 모바일 위치 조정 */
  @media (max-width: 768px) {
    #scroll-to-top-btn {
      right: 20px;
      bottom: 100px;
      width: 44px;
      height: 44px;
      font-size: 1.5em;
    }
  }
  }

  /* Day 타이틀 직접 편집 스타일 */
  .day-title-editable {
    cursor: text;
    padding: 2px 4px; /* For better click/touch target */
    border-radius: 4px;
    transition: background-color 0.2s;
    min-width: 80px; /* 편집 시 최소 너비 */
    display: inline-block; /* span이 너비를 가질 수 있도록 */
  }
  .day-title-editable:focus {
    background-color: #e0f2f7;
    outline: 2px solid rgba(16,185,129,0.3);
  }


</style>
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<body>

<div id="header-title-fixed">
  <span id="app-title" contenteditable="true">📅 마케팅 체크리스트</span>
  <div id="share-buttons">
    <button class="header-action-btn" id="new-empty-checklist-btn" title="새 빈 체크리스트 생성">
      <span class="material-icons">note_add</span>
    </button>
    <button class="header-action-btn" id="btn-save-all" title="현재 상태 저장">
      <span class="material-icons">save</span>
    </button>
    <button class="download-btn" id="btn-download" title="다운로드">
      <span class="material-icons">download</span>
    </button>
    <button class="share-btn" id="btn-webshare" title="공유">
      <span class="material-icons">share</span>
    </button>
    <a class="share-btn" id="btn-kakaotalk" title="카카오톡 공유" href="#">
      <span class="material-icons">chat</span>
    </a>
  </div>
</div>

<div id="progress-container" aria-label="전체 진행률">
  <div id="progress-text">전체 진행률: 0%</div>
  <div id="progress-bar-bg" aria-hidden="true">
    <div id="progress-bar-fill"></div>
  </div>
</div>

<div id="circular-progress-wrapper">
<div id="circular-progress">
  <svg class="circular-svg" viewBox="0 0 100 100">
  <defs>
    <linearGradient id="circular-gradient" x1="1" y1="0" x2="0" y2="1">
      <stop offset="0%" stop-color="#6ee7b7"/>
      <stop offset="100%" stop-color="#10b981"/>
    </linearGradient>
  </defs>
  <circle class="circular-bg" cx="50" cy="50" r="40"/>
  <circle class="circular-fg" cx="50" cy="50" r="40" style="stroke-linecap: round;"/>
  <text class="circular-text" x="50" y="42" id="circular-progress-value">0%</text>
  <text class="circular-label" x="50" y="62">전체</text>
</svg>
</div>

<button id="scroll-to-top-btn" title="맨 위로 이동" aria-label="맨 위로">
  <span class="material-icons">arrow_upward</span>
</button>
</div>

<h1>📅 마케팅 30일 체크리스트</h1>

<div id="checklist-wrapper">
    <div id="checklist"></div>
    <button class="scroll-button left" id="scroll-left-btn" aria-label="이전 카드 보기">‹</button>
    <button class="scroll-button right" id="scroll-right-btn" aria-label="다음 카드 보기">›</button>
</div>


<div id="buttons">
  <button id="reset-btn" title="모든 체크 항목 초기화">🔄 전체 체크 초기화</button>
  <button id="print-pdf-btn" title="인쇄 및 PDF 저장">🖨️ 인쇄 / PDF 저장</button>
  <button id="show-result-btn" title="진단 결과 보기">📋 진단 결과 보기</button>
</div>

<div id="diagnosis-result" aria-live="polite" style="display:none;">
  <button id="print-result-btn" style="display:none;">🖨️ 진단 결과만 인쇄/PDF</button>
  <h3>📝 진단 결과</h3>
  <p id="summary"></p>
  <ul id="completed-tasks-list"></ul>
</div>


<script>

// 맨 위로 버튼 기능
const scrollToTopBtn = document.getElementById('scroll-to-top-btn');

// 버튼 클릭 시 맨 위로 부드럽게 스크롤
scrollToTopBtn.addEventListener('click', function() {
  window.scrollTo({ top: 0, behavior: 'smooth' });
});

// 스크롤 위치에 따라 버튼 표시/숨김
function handleScrollToTopBtn() {
  if (window.scrollY > window.innerHeight * 0.3) {
    scrollToTopBtn.classList.remove('hide');
  } else {
    scrollToTopBtn.classList.add('hide');
  }
}
window.addEventListener('scroll', handleScrollToTopBtn);
handleScrollToTopBtn();

// 기본 체크리스트 데이터 (모든 태스크에 고유 ID 추가)
let checklistData = [
  { day: 1, category: "전략 수립 및 시장 분석", tasks: [
      { id: crypto.randomUUID(), content: "📊 지난달 KPI 리뷰" },
      { id: crypto.randomUUID(), content: "📝 성과 요약 정리" }
  ]},
  { day: 2, category: "전략 수립 및 시장 분석", tasks: [
      { id: crypto.randomUUID(), content: "🎯 이달 KPI 및 목표 설정" },
      { id: crypto.randomUUID(), content: "📈 핵심 지표 선정" }
  ]},
  { day: 3, category: "전략 수립 및 시장 분석", tasks: [
      { id: crypto.randomUUID(), content: "🔍 시장 트렌드 조사" },
      { id: crypto.randomUUID(), content: "🌐 타겟 시장 데이터 수집" }
  ]},
  { day: 4, category: "전략 수립 및 시장 분석", tasks: [
      { id: crypto.randomUUID(), content: "👀 경쟁사 마케팅 전략 분석" },
      { id: crypto.randomUUID(), content: "📸 광고 예시 수집" }
  ]},
  { day: 5, category: "전략 수립 및 시장 분석", tasks: [
      { id: crypto.randomUUID(), content: "👤 페르소나 업데이트" },
      { id: crypto.randomUUID(), content: "🔬 사용자 세분화" }
  ]},
  { day: 6, category: "콘텐츠 기획 및 제작", tasks: [
      { id: crypto.randomUUID(), content: "🎨 캠페인 주제/목표 설정" },
      { id: crypto.randomUUID(), content: "💡 슬로건 아이디어 도출" }
  ]},
  { day: 7, category: "콘텐츠 기획 및 제작", tasks: [
      { id: crypto.randomUUID(), content: "🧠 콘텐츠 아이디어 브레인스토밍" },
      { id: crypto.randomUUID(), content: "📚 내용 분류 (SNS, 이메일 등)" }
  ]},
  { day: 8, category: "콘텐츠 기획 및 제작", tasks: [
      { id: crypto.randomUUID(), content: "📅 캘린더에 콘텐츠 배치" },
      { id: crypto.randomUUID(), content: "🛠️ 콘텐츠 제작 일정 확정" }
  ]},
  { day: 9, category: "콘텐츠 기획 및 제작", tasks: [
      { id: crypto.randomUUID(), content: "✍️ 블로그 콘텐츠 초안 작성" },
      { id: crypto.randomUUID(), content: "🔎 키워드 포함 여부 점검" }
  ]},
  { day: 10, category: "콘텐츠 기획 및 제작", tasks: [
      { id: crypto.randomUUID(), content: "🖼️ SNS 콘텐츠 디자인 제작" },
      { id: crypto.randomUUID(), content: "📏 포맷별 이미지 준비" }
  ]},
  { day: 11, category: "콘텐츠 기획 및 제작", tasks: [
      { id: crypto.randomUUID(), content: "🪧 광고 소재 제작" },
      { id: crypto.randomUUID(), content: "🧪 A/B 테스트용 배너 2종" }
  ]},
  { day: 12, category: "콘텐츠 기획 및 제작", tasks: [
      { id: crypto.randomUUID(), content: "📬 이메일 템플릿 디자인" },
      { id: crypto.randomUUID(), content: "🎯 CTA 버튼 문구 결정" }
  ]},
  { day: 13, category: "콘텐츠 기획 및 제작", tasks: [
      { id: crypto.randomUUID(), content: "🧱 랜딩 페이지 구조 기획" },
      { id: crypto.randomUUID(), content: "📋 초안 피드백 수렴" }
  ]},
  { day: 14, category: "콘텐츠 기획 및 제작", tasks: [
      { id: crypto.randomUUID(), content: "🧐 모든 콘텐츠 최종 검토" },
      { id: crypto.randomUUID(), content: "✅ 오류 및 오타 수정" }
  ]},
  { day: 15, category: "캠페인 실행", tasks: [
      { id: crypto.randomUUID(), content: "🚀 콘텐츠 발행 시작" },
      { id: crypto.randomUUID(), content: "📢 SNS 예약 게시 설정" }
  ]},
  { day: 16, category: "캠페인 실행", tasks: [
      { id: crypto.randomUUID(), content: "📊 광고 캠페인 세팅" },
      { id: crypto.randomUUID(), content: "🛠️ 타겟팅 세부 설정" }
  ]},
  { day: 17, category: "캠페인 실행", tasks: [
      { id: crypto.randomUUID(), content: "💰 광고 예산 배분" },
      { id: crypto.randomUUID(), content: "📅 일정 재확인" }
  ]},
  { day: 18, category: "성과 측정 및 분석", tasks: [
      { id: crypto.randomUUID(), content: "🕵️‍♂️ 성과 모니터링 방법 설정" },
      { id: crypto.randomUUID(), content: "📈 실시간 데이터 대시보드 구축" }
  ]},
  { day: 19, category: "성과 측정 및 분석", tasks: [
      { id: crypto.randomUUID(), content: "📝 주간 리포트 템플릿 제작" },
      { id: crypto.randomUUID(), content: "📤 자동 발송 시스템 점검" }
  ]},
  { day: 20, category: "성과 측정 및 분석", tasks: [
      { id: crypto.randomUUID(), content: "👥 고객 피드백 수집 계획" },
      { id: crypto.randomUUID(), content: "📞 인터뷰 대상 선정" }
  ]},
  { day: 21, category: "콘텐츠 확장 및 최적화", tasks: [
      { id: crypto.randomUUID(), content: "🎥 프로모션 영상 기획" },
      { id: crypto.randomUUID(), content: "🎬 촬영 일정 조율" }
  ]},
  { day: 22, category: "콘텐츠 확장 및 최적화", tasks: [
      { id: crypto.randomUUID(), content: "📺 영상 편집" },
      { id: crypto.randomUUID(), content: "🎨 썸네일 제작" }
  ]},
  { day: 2.3, category: "콘텐츠 확장 및 최적화", tasks: [
      { id: crypto.randomUUID(), content: "🗣️ 인플루언서 협업 검토" },
      { id: crypto.randomUUID(), content: "🤝 계약 조건 협상" }
  ]},
  { day: 24, category: "고객 커뮤니케이션", tasks: [
      { id: crypto.randomUUID(), content: "💬 SNS 댓글 및 문의 대응" },
      { id: crypto.randomUUID(), content: "📞 고객 상담 프로세스 점검" }
  ]},
  { day: 25, category: "개선 및 반복", tasks: [
      { id: crypto.randomUUID(), content: "💡 개선 아이디어 도출 회의" },
      { id: crypto.randomUUID(), content: "📝 실행 계획 수립" }
  ]},
  { day: 26, category: "개선 및 반복", tasks: [
      { id: crypto.randomUUID(), content: "📢 리타겟팅 캠페인 시작" },
      { id: crypto.randomUUID(), content: "🔄 광고 소재 교체" }
  ]},
  { day: 27, category: "개선 및 반복", tasks: [
      { id: crypto.randomUUID(), content: "📊 캠페인 성과 분석" },
      { id: crypto.randomUUID(), content: "📈 보고서 작성" }
  ]},
  { day: 28, category: "데이터 관리 및 정리", tasks: [
      { id: crypto.randomUUID(), content: "🧹 데이터 정리 및 백업" },
      { id: crypto.randomUUID(), content: "📂 파일 아카이브 완료" }
  ]},
  { day: 29, category: "성과 공유 및 다음 스텝", tasks: [
      { id: crypto.randomUUID(), content: "🎉 성공 사례 공유" },
      { id: crypto.randomUUID(), content: "👏 팀원 피드백 수집" }
  ]},
  { day: 30, category: "성과 공유 및 다음 스텝", tasks: [
      { id: crypto.randomUUID(), content: "🔔 다음 달 준비 시작" },
      { id: crypto.randomUUID(), content: "📅 일정 계획 수립" }
  ]}
];


// DOM 요소 가져오기
const checklist = document.getElementById("checklist");
const checklistWrapper = document.getElementById("checklist-wrapper");
const progressText = document.getElementById("progress-text");
const progressBarFill = document.getElementById("progress-bar-fill");
const resetBtn = document.getElementById("reset-btn");
const printPdfBtn = document.getElementById("print-pdf-btn");
const diagnosisResult = document.getElementById("diagnosis-result");
const summaryText = document.getElementById("summary");
const completedTasksList = document.getElementById("completed-tasks-list");
const showResultBtn = document.getElementById("show-result-btn");
const printResultBtn = document.getElementById("print-result-btn");
const circularProgressValue = document.getElementById("circular-progress-value");
const circularFg = document.querySelector(".circular-fg");
const scrollLeftBtn = document.getElementById("scroll-left-btn");
const scrollRightBtn = document.getElementById("scroll-right-btn");
// 헤더에 있는 새 빈 체크리스트 생성 버튼
const newEmptyChecklistBtn = document.getElementById("new-empty-checklist-btn");
// 헤더에 있는 저장 버튼
const saveAllBtn = document.getElementById("btn-save-all");
// 앱 타이틀
const appTitleElement = document.getElementById("app-title");


// 원형 진행률 계산을 위한 상수
const CIRCUMFERENCE = 2 * Math.PI * 40; // SVG 원의 반지름 (r=40px)에 따라 둘레 계산

// 로컬 스토리지 키
const STORAGE_KEY_DATA = "marketingChecklistData"; // 체크리스트 데이터 자체 저장
const STORAGE_KEY_CHECKS = "marketingChecklistChecks"; // 체크 상태만 저장
const STORAGE_KEY_APP_TITLE = "marketingChecklistAppTitle"; // 앱 제목 저장

// 로컬 스토리지에서 저장된 상태 불러오기 또는 초기화
let checklistState = {};

// 드래그 관련 변수들 선언을 최상단으로 이동
let isDragging = false;
let startX;
let scrollLeft;

// 체크리스트 상태를 로컬 스토리지에 저장하는 함수
function saveState() {
  localStorage.setItem(STORAGE_KEY_DATA, JSON.stringify(checklistData)); // checklistData 전체 저장
  localStorage.setItem(STORAGE_KEY_CHECKS, JSON.stringify(checklistState)); // 체크 상태 별도로 저장
  localStorage.setItem(STORAGE_KEY_APP_TITLE, appTitleElement.textContent.trim()); // 앱 제목 저장
  console.log("체크리스트 데이터 및 상태가 저장되었습니다.");
}

/**
 * 로컬 스토리지에서 저장된 체크리스트 데이터와 상태를 불러옵니다.
 * 기존 데이터에 ID가 없는 경우 새로 생성하고, 데이터가 없는 경우 기본값을 설정합니다.
 */
function loadState() {
    const savedData = localStorage.getItem(STORAGE_KEY_DATA);
    const savedChecks = localStorage.getItem(STORAGE_KEY_CHECKS);
    const savedAppTitle = localStorage.getItem(STORAGE_KEY_APP_TITLE);

    if (savedData) {
        checklistData = JSON.parse(savedData);
        // 저장된 데이터의 모든 태스크가 ID를 가지고 있는지 확인 (이전 버전 호환성)
        checklistData.forEach(dayObj => {
            dayObj.tasks = dayObj.tasks.map(task => {
                // 이전 버전에서 문자열로 저장된 경우 또는 ID가 없는 경우
                if (typeof task === 'string' || !task.id) {
                    return { id: crypto.randomUUID(), content: typeof task === 'string' ? task : task.content };
                }
                return task;
            });
            // displayTitle 속성이 없는 경우 추가 (이전 버전 호환성)
            if (!dayObj.displayTitle) {
                dayObj.displayTitle = `📅 Day ${dayObj.day}`;
            }
        });
    } else {
        // 로컬 스토리지에 데이터가 없는 경우, 초기 checklistData를 사용
        // 초기 checklistData는 이미 ID를 가지고 있도록 정의됨
        // displayTitle 추가
        checklistData.forEach(dayObj => {
            if (!dayObj.displayTitle) {
                dayObj.displayTitle = `📅 Day ${dayObj.day}`;
            }
        });
    }

    if (savedChecks) {
        checklistState = JSON.parse(savedChecks);
    } else {
        checklistState = {};
    }

    if (savedAppTitle) {
        appTitleElement.textContent = savedAppTitle;
    }
}


/**
 * 커스텀 알림/확인 모달을 생성하고 표시합니다.
 * @param {string} message - 모달에 표시할 메시지.
 * @param {string} type - 'alert', 'confirm', 'prompt' 중 하나.
 * @param {string} [defaultValue=''] - prompt 타입일 경우 기본 값.
 * @returns {Promise<string|boolean|null>} - confirm은 true/false, prompt는 입력값, alert는 null 반환.
 */
function showCustomModal(message, type, defaultValue = '') {
  return new Promise((resolve) => {
    const overlay = document.createElement('div');
    overlay.className = 'custom-modal-overlay';

    const content = document.createElement('div');
    content.className = 'custom-modal-content';

    const messagePara = document.createElement('p');
    messagePara.textContent = message;
    content.appendChild(messagePara);

    let inputField;
    if (type === 'prompt') {
      inputField = document.createElement('input');
      inputField.type = 'text';
      inputField.value = defaultValue;
      content.appendChild(inputField);
    }

    const buttonContainer = document.createElement('div');

    if (type === 'alert') {
      const okButton = document.createElement('button');
      okButton.textContent = '확인';
      okButton.className = 'modal-confirm-btn';
      okButton.onclick = () => {
        document.body.removeChild(overlay);
        resolve(null);
      };
      buttonContainer.appendChild(okButton);
    } else if (type === 'confirm') {
      const yesButton = document.createElement('button');
      yesButton.textContent = '예';
      yesButton.className = 'modal-confirm-btn';
      yesButton.onclick = () => {
        document.body.removeChild(overlay);
        resolve(true);
      };
      buttonContainer.appendChild(yesButton);

      const noButton = document.createElement('button');
      noButton.textContent = '아니오';
      noButton.className = 'modal-cancel-btn';
      noButton.onclick = () => {
        document.body.removeChild(overlay);
        resolve(false);
      };
      buttonContainer.appendChild(noButton);
    } else if (type === 'prompt') {
      const okButton = document.createElement('button');
      okButton.textContent = '확인';
      okButton.className = 'modal-confirm-btn';
      okButton.onclick = () => {
        document.body.removeChild(overlay);
        resolve(inputField.value);
      };
      buttonContainer.appendChild(okButton);

      const cancelButton = document.createElement('button');
      cancelButton.textContent = '취소';
      cancelButton.className = 'modal-cancel-btn';
      cancelButton.onclick = () => {
        document.body.removeChild(overlay);
        resolve(null); // 취소 시 null 반환
      };
      buttonContainer.appendChild(cancelButton);
      // prompt일 경우 input 필드에서 Enter 키 입력 시 확인 버튼 클릭 효과
      inputField.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          okButton.click();
        }
      });
    }

    content.appendChild(buttonContainer);
    overlay.appendChild(content);
    document.body.appendChild(overlay);

    // prompt일 경우 input 필드에 자동으로 포커스
    if (inputField) {
      inputField.focus();
    }
  });
}


// 원형 진행률을 업데이트하는 함수
function updateCircularProgress(percent) {
  if (circularProgressValue) {
    circularProgressValue.textContent = percent + "%";
  }
  if (circularFg) {
    const offset = CIRCUMFERENCE * (1 - percent / 100);
    // 반드시 둘레 두 번 반복!
    circularFg.style.strokeDasharray = `${CIRCUMFERENCE} ${CIRCUMFERENCE}`;
    circularFg.style.strokeDashoffset = offset;
  }
}

// 전체 진행률을 업데이트하는 함수
function updateOverallProgress() {
  const totalTasks = checklistData.reduce((acc, day) => acc + day.tasks.length, 0);
  const doneTasks = Object.values(checklistState).filter(v => v).length;
  const percent = totalTasks ? Math.round((doneTasks / totalTasks) * 100) : 0;
  progressText.textContent = `전체 진행률: ${percent}%`;
  progressBarFill.style.width = percent + "%";
  updateCircularProgress(percent); // 원형 진행률도 업데이트
}

// 각 Day 섹션의 진행률을 업데이트하는 함수
function updateDayProgress(day) {
  day = Number(day);
  const daySection = document.getElementById(`day-${day}`);
  const dayObj = checklistData.find(d => Number(d.day) === day);
  if (!daySection || !dayObj) return; // 요소나 데이터가 없으면 종료

  const tasks = dayObj.tasks;
  let doneCount = 0;
  for (const task of tasks) { // ID 기반으로 변경
    if (checklistState[task.id]) doneCount++; // 완료된 태스크 카운트
  }
  const percent = tasks.length ? Math.round((doneCount / tasks.length) * 100) : 0;

  // 퍼센트 텍스트 업데이트
  const progressTextElement = daySection.querySelector(".day-progress-text");
  if (progressTextElement) progressTextElement.textContent = `${percent}% 완료`;
  // 프로그레스 바 업데이트
  const progressBarFillElement = daySection.querySelector(".day-progress-bar-fill");
  if (progressBarFillElement) progressBarFillElement.style.width = percent + "%";
}

// 카테고리 완료 여부 확인 및 다음 카테고리로 스크롤하는 함수
function checkCategoryCompletionAndScroll(updatedDay) {
    const dayItem = checklistData.find(d => d.day === updatedDay);
    if (!dayItem) return;

    const categoryName = dayItem.category;
    const daysInThisCategory = checklistData.filter(d => d.category === categoryName);

    let allTasksInCategoriesCompleted = true;
    for (const dayObj of daysInThisCategory) {
        for (const task of dayObj.tasks) { // ID 기반으로 변경
            if (!checklistState[task.id]) {
                allTasksInCategoriesCompleted = false;
                break;
            }
        }
        if (!allTasksInCategoriesCompleted) break;
    }

    if (allTasksInCategoriesCompleted) {
        const currentCategoryBoxId = `category-header-${categoryName.replace(/\s/g, '-')}`;
        const currentCategoryBox = document.getElementById(currentCategoryBoxId);
        // 부모 요소를 찾아서 다음 형제 요소로 이동
        if (currentCategoryBox) {
            const parentCategoryBox = currentCategoryBox.closest('.category-box');
            const nextCategoryBox = parentCategoryBox ? parentCategoryBox.nextElementSibling : null;

            if (nextCategoryBox && nextCategoryBox.classList.contains('category-box')) {
                checklist.scrollTo({
                    left: nextCategoryBox.offsetLeft - checklist.offsetLeft, // 다음 카드의 시작 위치로 스크롤
                    behavior: 'smooth'
                });
            }
        }
    }
}

// 화살표 버튼 가시성 업데이트 함수
function updateArrowButtonVisibility() {
    const maxScrollLeft = checklist.scrollWidth - checklist.clientWidth;

    if (checklist.scrollLeft <= 5) { // 거의 맨 왼쪽일 때
        scrollLeftBtn.classList.add('hidden');
    } else {
        scrollLeftBtn.classList.remove('hidden');
    }

    if (checklist.scrollLeft >= maxScrollLeft - 5) { // 거의 맨 오른쪽일 때
        scrollRightBtn.classList.add('hidden');
    } else {
        scrollRightBtn.classList.remove('hidden');
    }
}

// 화살표 버튼 수직 위치 업데이트 함수 (스크롤에 따라 움직이도록)
function updateArrowVerticalPosition() {
    const checklistRect = checklist.getBoundingClientRect(); // checklist 요소의 위치와 크기
    const arrowHeight = scrollLeftBtn.offsetHeight; // 화살표 버튼의 높이

    // checklist 컨테이너의 보이는 부분의 세로 중앙을 계산합니다.
    // viewport 기준 checklist 컨테이너의 상단 + (checklist 컨테이너의 높이 / 2) - (화살표 높이 / 2)
    let targetTop = checklistRect.top + (checklistRect.height / 2) - (arrowHeight / 2);

    // 고정 헤더의 높이를 고려하여 화살표가 헤더에 가려지지 않도록 조정
    const headerHeight = document.getElementById('header-title-fixed').offsetHeight;
    if (targetTop < headerHeight + 10) { // 헤더 아래 10px 여백
        targetTop = headerHeight + 10;
    }

    // 화면 하단에 너무 가깝게 붙지 않도록 조정
    if (targetTop > window.innerHeight - arrowHeight - 20) { // 하단 20px 여백
        targetTop = window.innerHeight - arrowHeight - 20;
    }

    // 계산된 top 위치를 화살표 버튼에 적용
    scrollLeftBtn.style.top = `${targetTop}px`;
    scrollRightBtn.style.top = `${targetTop}px`;
}


// 화살표 버튼 클릭 이벤트 리스너
scrollLeftBtn.addEventListener('click', () => {
    const currentScrollLeft = checklist.scrollLeft;
    let targetScrollLeft = currentScrollLeft;
    const categoryBoxes = checklist.querySelectorAll('.category-box');

    // 현재 보이는 카드보다 왼쪽으로 이동할 카드 찾기
    for (let i = categoryBoxes.length - 1; i >= 0; i--) {
        const box = categoryBoxes[i];
        if (box.offsetLeft < currentScrollLeft - 10) { // 현재 스크롤 위치보다 왼쪽에 있는 카드
            targetScrollLeft = box.offsetLeft - 20; // 20px 여백 추가
            break;
        }
        if (i === 0) { // 첫번째 카드인 경우 맨 왼쪽으로
            targetScrollLeft = 0;
        }
    }
    checklist.scrollTo({
        left: targetScrollLeft,
        behavior: 'smooth'
    });
});

scrollRightBtn.addEventListener('click', () => {
    const currentScrollLeft = checklist.scrollLeft;
    let targetScrollLeft = currentScrollLeft;
    const categoryBoxes = checklist.querySelectorAll('.category-box');

    // 현재 보이는 영역의 오른쪽 경계보다 다음 박스가 시작될 때
    for (let i = 0; i < categoryBoxes.length; i++) {
        const box = categoryBoxes[i];
        if (box.offsetLeft > currentScrollLeft + checklist.clientWidth - 10) {
            targetScrollLeft = box.offsetLeft;
            // 모바일 뷰포트에서 한 칸씩 이동하도록 조정
            if (window.innerWidth <= 768) {
                targetScrollLeft -= 10; // 모바일 좌측 패딩
            }
            break;
        }
        if (i === categoryBoxes.length - 1) { // 마지막 카드인 경우 맨 오른쪽으로
            targetScrollLeft = checklist.scrollWidth - checklist.clientWidth;
        }
    }
    checklist.scrollTo({
        left: targetScrollLeft,
        behavior: 'smooth'
    });
});

// 드래그 기능 구현
checklist.addEventListener('mousedown', (e) => {
  isDragging = true;
  checklist.classList.add('grabbing');
  startX = e.pageX - checklist.offsetLeft;
  scrollLeft = checklist.scrollLeft;
  // 드래그 중 텍스트 선택 방지
  e.preventDefault();
});

checklist.addEventListener('mouseleave', () => {
  isDragging = false;
  checklist.classList.remove('grabbing');
});

checklist.addEventListener('mouseup', () => {
  isDragging = false;
  checklist.classList.remove('grabbing');
});

checklist.addEventListener('mousemove', (e) => {
  if (!isDragging) return;
  e.preventDefault(); // 기본 드래그 동작(스크롤) 방지
  const x = e.pageX - checklist.offsetLeft;
  const walk = (x - startX); // 이동 거리
  checklist.scrollLeft = scrollLeft - walk; // 스크롤 위치 업데이트
});

// 터치 이벤트 (모바일 드래그/스와이프)
checklist.addEventListener('touchstart', (e) => {
    isDragging = true;
    checklist.classList.add('grabbing');
    startX = e.touches[0].pageX - checklist.offsetLeft;
    scrollLeft = checklist.scrollLeft;
});

checklist.addEventListener('touchend', () => {
    isDragging = false;
    checklist.classList.remove('grabbing');
});

checklist.addEventListener('touchmove', (e) => {
    if (!isDragging) return;
    const x = e.touches[0].pageX - checklist.offsetLeft;
    const walk = (x - startX);
    checklist.scrollLeft = scrollLeft - walk;
});


// 스크롤 이벤트 리스너 (화살표 가시성 업데이트)
checklist.addEventListener('scroll', updateArrowButtonVisibility);


/**
 * 새 태스크를 추가하는 함수
 * @param {string} categoryName - 태스크가 속할 카테고리 이름
 * @param {number} dayNumber - 태스크가 속할 Day 번호
 * @param {string} taskContent - 추가할 태스크 내용
 * @param {string|null} [insertAfterTaskId=null] - 이 태스크 ID 다음에 새 태스크를 삽입합니다. null이면 마지막에 추가.
 */
function addTaskToDay(categoryName, dayNumber, taskContent, insertAfterTaskId = null) {
    const dayObj = checklistData.find(d => d.category === categoryName && d.day === dayNumber);
    if (dayObj) {
        const newTask = { id: crypto.randomUUID(), content: taskContent };
        if (insertAfterTaskId) {
            const index = dayObj.tasks.findIndex(t => t.id === insertAfterTaskId);
            if (index !== -1) {
                dayObj.tasks.splice(index + 1, 0, newTask); // 특정 태스크 뒤에 삽입
            } else {
                dayObj.tasks.push(newTask); // ID를 찾지 못하면 그냥 마지막에 추가
            }
        } else {
            dayObj.tasks.push(newTask); // 마지막에 추가
        }
        checklistState[newTask.id] = false; // 새 태스크의 상태는 기본적으로 false (미완료)
        saveState();
        buildChecklist(); // UI 다시 그리기
        updateOverallProgress();
    }
}

/**
 * 새 Day 섹션을 추가하는 함수
 * @param {string} categoryName - Day가 속할 카테고리 이름
 * @param {Array<Object>} [tasks=[]] - 새로운 Day에 포함될 태스크 배열 (선택 사항, {id, content} 형식)
 */
function addDayToCategory(categoryName, tasks = []) {
    // 해당 카테고리의 마지막 Day 번호 찾기
    const daysInThisCategory = checklistData.filter(d => d.category === categoryName);
    let maxDayInCat = daysInThisCategory.length > 0 ? Math.max(...daysInThisCategory.map(item => item.day)) : 0;
    
    // 전체 체크리스트 데이터의 최대 Day 번호 찾기 (겹치지 않도록)
    let currentMaxOverallDay = checklistData.length > 0 ? Math.max(...checklistData.map(item => item.day)) : 0;
    
    // 새로운 Day 번호는 해당 카테고리의 다음 번호 또는 전체의 다음 번호 중 큰 값
    // 이렇게 하면 Day 번호가 유니크하게 유지되면서도 가능한 한 연속적으로 부여됩니다.
    const newDayNumber = Math.max(maxDayInCat + 1, currentMaxOverallDay + 1);

    const newDayObj = { day: newDayNumber, category: categoryName, tasks: tasks, displayTitle: `📅 Day ${newDayNumber}` }; // Add displayTitle
    checklistData.push(newDayObj);
    checklistData.sort((a, b) => a.day - b.day); // Day 순서대로 정렬
    saveState();
    buildChecklist(); // UI 다시 그리기
    updateOverallProgress();
}

/**
 * 태스크 항목을 삭제하는 함수
 * @param {string} taskIdToDelete - 삭제할 태스크의 고유 ID
 * @param {number} dayNumber - 해당 태스크의 Day 번호
 */
async function deleteTask(taskIdToDelete, dayNumber) {
    const confirmed = await showCustomModal("이 태스크를 삭제하시겠습니까?", 'confirm');
    if (confirmed) {
        const dayObj = checklistData.find(d => d.day === dayNumber);
        if (dayObj) {
            dayObj.tasks = dayObj.tasks.filter(task => task.id !== taskIdToDelete); // ID로 태스크 제거
            delete checklistState[taskIdToDelete]; // 체크 상태 삭제
            saveState();
            buildChecklist(); // UI 다시 그리기
            updateOverallProgress();
        }
    }
}

/**
 * Day 섹션 전체를 삭제하는 함수
 * @param {number} dayToDelete - 삭제할 Day 번호
 */
async function deleteDay(dayToDelete) {
    const confirmed = await showCustomModal(`Day ${dayToDelete} 섹션 전체를 삭제하시겠습니까?`, 'confirm');
    if (confirmed) {
        const dayObj = checklistData.find(d => d.day === dayToDelete);
        if (dayObj) {
            dayObj.tasks.forEach(task => { // 해당 Day의 모든 태스크 체크 상태 삭제
                delete checklistState[task.id];
            });
        }
        checklistData = checklistData.filter(d => d.day !== dayToDelete);
        saveState();
        buildChecklist(); // UI 다시 그리기
        updateOverallProgress();
    }
}

/**
 * 카테고리 전체를 삭제하는 함수
 * @param {string} categoryToDelete - 삭제할 카테고리 이름
 */
async function deleteCategory(categoryToDelete) {
    const confirmed = await showCustomModal(`'${categoryToDelete}' 카테고리 전체를 삭제하시겠습니까? (이 카테고리의 모든 Day와 태스크가 삭제됩니다)`, 'confirm');
    if (confirmed) {
        const daysInCat = checklistData.filter(d => d.category === categoryToDelete);
        daysInCat.forEach(dayObj => {
            dayObj.tasks.forEach(task => { // 해당 카테고리의 모든 Day와 태스크 체크 상태 삭제
                delete checklistState[task.id];
            });
        });
        checklistData = checklistData.filter(d => d.category !== categoryToDelete);
        saveState();
        buildChecklist(); // UI 다시 그리기
        updateOverallProgress();
    }
}

/**
 * 태스크 항목을 수정하는 함수
 * @param {string} taskIdToEdit - 수정할 태스크의 고유 ID
 * @param {number} dayNumber - 해당 태스크의 Day 번호
 * @param {string} currentText - 현재 태스크 내용
 */
async function editTask(taskIdToEdit, dayNumber, currentText) {
    const newText = await showCustomModal("태스크 내용을 수정하세요:", 'prompt', currentText);
    if (newText !== null && newText.trim() !== '') { // 취소하지 않고 빈 문자열도 아니면
        const dayObj = checklistData.find(d => d.day === dayNumber);
        if (dayObj) {
            const taskToUpdate = dayObj.tasks.find(task => task.id === taskIdToEdit);
            if (taskToUpdate) {
                taskToUpdate.content = newText.trim();
                saveState(); // 상태 저장
                buildChecklist(); // UI 다시 그리기
                updateOverallProgress();
            }
        }
    }
}

/**
 * 카테고리 이름을 수정하는 함수
 * @param {string} oldCategoryName - 기존 카테고리 이름
 */
async function editCategory(oldCategoryName) {
    const newCategoryName = await showCustomModal("카테고리 이름을 수정하세요:", 'prompt', oldCategoryName);
    if (newCategoryName !== null && newCategoryName.trim() !== '' && newCategoryName.trim() !== oldCategoryName) {
        checklistData.forEach(item => {
            if (item.category === oldCategoryName) {
                item.category = newCategoryName.trim();
            }
        });
        saveState();
        buildChecklist();
        updateOverallProgress();
    }
}


// 체크리스트 UI를 동적으로 생성하는 함수
function buildChecklist() {
  checklist.innerHTML = ""; // 기존 체크리스트 초기화

  // 데이터를 카테고리별로 그룹화
  const categories = {};
  checklistData.forEach(item => {
    if (!categories[item.category]) {
      categories[item.category] = [];
    }
    categories[item.category].push(item);
  });

  // 그룹화된 카테고리별로 UI 생성
  for (const categoryName in categories) {
    const categoryBox = document.createElement("div");
    categoryBox.className = "category-box";
    categoryBox.setAttribute("aria-labelledby", `category-header-${categoryName.replace(/\s/g, '-')}`);

    const categoryHeader = document.createElement("h2");
    const categoryTitleSpan = document.createElement('span');
    categoryTitleSpan.id = `category-header-${categoryName.replace(/\s/g, '-')}`;
    
    // 카테고리별 Material Icons 설정
    let icon = '';
    switch (categoryName) {
      case '전략 수립 및 시장 분석': icon = 'insights'; break;
      case '콘텐츠 기획 및 제작': icon = 'edit'; break;
      case '캠페인 실행': icon = 'rocket_launch'; break;
      case '성과 측정 및 분석': icon = 'analytics'; break;
      case '콘텐츠 확장 및 최적화': icon = 'auto_awesome'; break;
      case '고객 커뮤니케이션': icon = 'chat'; break;
      case '개선 및 반복': icon = 'loop'; break;
      case '데이터 관리 및 정리': icon = 'folder_open'; break;
      case '성과 공유 및 다음 스텝': icon = 'celebration'; break;
      default: icon = 'category';
    }
    categoryTitleSpan.innerHTML = `<span class="material-icons">${icon}</span> ${categoryName}`;
    categoryHeader.appendChild(categoryTitleSpan);

    // 카테고리 액션 버튼들
    const categoryActions = document.createElement('div');
    categoryActions.className = 'category-actions';

    // 카테고리 수정 버튼
    const editCategoryBtn = document.createElement('span');
    editCategoryBtn.className = 'material-icons edit-category-btn';
    editCategoryBtn.textContent = 'edit';
    editCategoryBtn.title = '카테고리 이름 수정';
    editCategoryBtn.onclick = () => editCategory(categoryName);
    categoryActions.appendChild(editCategoryBtn);

    // 카테고리 삭제 버튼
    const deleteCategoryBtn = document.createElement('span');
    deleteCategoryBtn.className = 'material-icons delete-category-btn';
    deleteCategoryBtn.textContent = 'close';
    deleteCategoryBtn.title = '카테고리 삭제';
    deleteCategoryBtn.onclick = () => deleteCategory(categoryName);
    categoryActions.appendChild(deleteCategoryBtn);
    
    categoryHeader.appendChild(categoryActions); // 액션 버튼 그룹 추가
    
    categoryBox.appendChild(categoryHeader);

    // 각 카테고리 내의 Day 섹션들 추가
    categories[categoryName].forEach((item) => { // 'item'은 day, category, tasks, displayTitle을 포함
      const day = item.day;

      const daySection = document.createElement("section");
      daySection.className = "day-section";
      daySection.id = `day-${day}`;
      daySection.setAttribute("aria-labelledby", `day-header-${day}`);

      // Day 헤더 (Day 타이틀 텍스트 + 오른쪽 진행률 텍스트 + 수정/삭제 버튼)
      const dayHeader = document.createElement("h3");
      dayHeader.id = `day-header-${day}`;
      dayHeader.style.display = "flex";
      dayHeader.style.justifyContent = "space-between";
      dayHeader.style.alignItems = "center";

      // Day 타이틀 (편집 가능하도록)
      const dayTitle = document.createElement("span");
      dayTitle.className = "day-title-editable"; // 새 스타일 클래스
      dayTitle.contentEditable = "true"; // 편집 가능
      dayTitle.textContent = item.displayTitle; // displayTitle 사용
      dayTitle.setAttribute('data-day-id', day); // 내부 숫자 day 값을 데이터 속성으로 저장

      // Day 타이틀 편집 시 이벤트 리스너
      dayTitle.addEventListener('blur', function() {
          const currentDayNumber = parseInt(this.getAttribute('data-day-id'));
          const newDisplayTitle = this.textContent.trim();
          const dayObj = checklistData.find(d => d.day === currentDayNumber);
          if (dayObj && dayObj.displayTitle !== newDisplayTitle) {
              dayObj.displayTitle = newDisplayTitle;
              saveState();
              updateOverallProgress();
          }
      });
      dayTitle.addEventListener('keypress', function(e) {
          if (e.key === 'Enter') {
              e.preventDefault(); // 새 줄 방지
              this.blur(); // blur 이벤트 발생시켜 저장
          }
      });
      dayHeader.appendChild(dayTitle);

      const dayProgressText = document.createElement("span");
      dayProgressText.className = "day-progress-text";
      dayProgressText.textContent = "0% 완료";

      const dayActions = document.createElement('div'); // Day 액션 버튼들을 위한 컨테이너
      dayActions.className = 'day-actions';
      dayActions.appendChild(dayProgressText); // 진행률 텍스트 추가

      // Day 수정 버튼 (Day 타이틀 편집을 트리거)
      const editDayBtn = document.createElement('span');
      editDayBtn.className = 'material-icons edit-day-btn';
      editDayBtn.textContent = 'edit';
      editDayBtn.title = 'Day 타이틀 수정';
      editDayBtn.onclick = () => {
          const targetDayTitleSpan = daySection.querySelector('.day-title-editable');
          if (targetDayTitleSpan) {
              targetDayTitleSpan.focus();
              // 커서를 텍스트 끝으로 이동
              const range = document.createRange();
              const sel = window.getSelection();
              range.selectNodeContents(targetDayTitleSpan);
              range.collapse(false); // 끝으로 축소
              sel.removeAllRanges();
              sel.addRange(range);
          }
      };
      dayActions.appendChild(editDayBtn);

      // Day 삭제 버튼 (아이콘 변경)
      const deleteDayBtn = document.createElement('span');
      deleteDayBtn.className = 'material-icons delete-day-btn';
      deleteDayBtn.textContent = 'close';
      deleteDayBtn.title = 'Day 삭제';
      deleteDayBtn.onclick = () => deleteDay(day);
      dayActions.appendChild(deleteDayBtn);

      dayHeader.appendChild(dayActions); // Day 액션 버튼 그룹 추가
      
      // Day 진행률 바
      const dayProgressBarBg = document.createElement("div");
      dayProgressBarBg.className = "day-progress-bar-bg";
      const dayProgressBarFill = document.createElement("div");
      dayProgressBarFill.className = "day-progress-bar-fill";
      dayProgressBarFill.style.width = "0%";
      dayProgressBarBg.appendChild(dayProgressBarFill);

      daySection.appendChild(dayHeader);
      daySection.appendChild(dayProgressBarBg);

      const ul = document.createElement("ul");

      // 각 태스크 항목 추가
      item.tasks.forEach((task) => { // i (index) 대신 task.id 사용
        const li = document.createElement("li");
        
        // '테스크 추가' 버튼 (체크박스 왼쪽, 항상 표시)
        // Material Icon 대신 SVG로 변경하여 그라데이션 적용
        const addTaskInlineBtn = document.createElement('button');
        addTaskInlineBtn.className = 'add-task-inline-btn';
        addTaskInlineBtn.title = '이 태스크 다음에 새로운 태스크 추가';
        addTaskInlineBtn.innerHTML = `
            <svg class="add-icon" viewBox="0 0 24 24">
                <defs>
                    <linearGradient id="addTaskGradient" x1="0" y1="0" x2="1" y2="1">
                        <stop offset="0%" stop-color="#34d399"/>
                        <stop offset="100%" stop-color="#059669"/>
                    </linearGradient>
                    <linearGradient id="addTaskGradientHover" x1="0" y1="0" x2="1" y2="1">
                        <stop offset="0%" stop-color="#059669"/>
                        <stop offset="100%" stop-color="#34d399"/>
                    </linearGradient>
                </defs>
                <path d="M12 4V20M20 12H4" stroke="url(#addTaskGradient)" stroke-width="2" stroke-linecap="round"/>
            </svg>
        `;
        addTaskInlineBtn.onclick = async () => {
            const newTaskContent = await showCustomModal("새로운 태스크 내용을 입력하세요:", 'prompt', '');
            if (newTaskContent !== null && newTaskContent.trim() !== '') {
                addTaskToDay(categoryName, day, newTaskContent, task.id); // 현재 태스크 ID 다음에 추가
            }
        };
        li.appendChild(addTaskInlineBtn);
        

        const label = document.createElement("label");
        const taskId = task.id; 
        label.setAttribute("for", taskId);

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.id = taskId;
        checkbox.checked = !!checklistState[taskId]; // 저장된 상태 적용

        const taskTextSpan = document.createElement("span"); // 태스크 텍스트를 담을 span
        taskTextSpan.textContent = task.content; // task 객체의 content 속성 사용
        taskTextSpan.classList.add('task-text'); // 클래스 추가

        if (checkbox.checked) {
          label.classList.add("checked"); // 체크된 항목 스타일 적용
        }

        // 체크박스 변경 이벤트 리스너
        checkbox.addEventListener("change", function() {
          checklistState[this.id] = this.checked; // 상태 업데이트
          saveState(); // 상태 저장

          if (this.checked) {
            label.classList.add("checked");
          } else {
            label.classList.remove("checked");
          }

          updateDayProgress(day); // Day 진행률 업데이트
          updateOverallProgress(); // 전체 진행률 업데이트
          checkCategoryCompletionAndScroll(day); // 카테고리 완료 여부 확인 및 스크롤
        });

        label.appendChild(checkbox);
        label.appendChild(taskTextSpan); // 태스크 텍스트 span 추가
        
        li.appendChild(label);

        // 태스크 액션 버튼들을 담을 컨테이너
        const taskActions = document.createElement('div');
        taskActions.className = 'task-actions';

        // 태스크 수정 버튼 추가
        const editTaskBtn = document.createElement('span');
        editTaskBtn.className = 'material-icons edit-task-btn';
        editTaskBtn.textContent = 'edit';
        editTaskBtn.title = '태스크 수정';
        editTaskBtn.onclick = () => editTask(task.id, day, task.content); // ID와 content 전달
        taskActions.appendChild(editTaskBtn);


        // 태스크 삭제 버튼 (아이콘 변경)
        const deleteTaskBtn = document.createElement('span');
        deleteTaskBtn.className = 'material-icons delete-task-btn';
        deleteTaskBtn.textContent = 'close';
        deleteTaskBtn.title = '태스크 삭제';
        deleteTaskBtn.onclick = () => deleteTask(task.id, day); // ID와 dayNumber 전달
        taskActions.appendChild(deleteTaskBtn);

        li.appendChild(taskActions); // 액션 버튼 컨테이너를 li에 추가

        ul.appendChild(li);
      });

      // Day에 태스크가 하나도 없을 경우의 '첫 태스크 추가' 버튼
      if (item.tasks.length === 0) { // tasks.length로 확인
          const addFirstTaskBtn = document.createElement('button');
          addFirstTaskBtn.className = 'add-first-task-btn'; // 새 클래스 적용
          addFirstTaskBtn.textContent = '➕ 첫 태스크 추가';
          addFirstTaskBtn.onclick = async () => {
              const newTaskContent = await showCustomModal("첫 태스크 내용을 입력하세요:", 'prompt', '');
              if (newTaskContent !== null && newTaskContent.trim() !== '') {
                  addTaskToDay(categoryName, day, newTaskContent); // ID 없이 추가 (Day의 첫 태스크)
              }
          };
          // 이 버튼은 ul의 자식이 아니라 daySection의 직접적인 자식으로 추가
          daySection.appendChild(addFirstTaskBtn);
      }
      
      daySection.appendChild(ul);


      categoryBox.appendChild(daySection); // Day 섹션을 카테고리 박스에 추가
      updateDayProgress(day); // Day 진행률 초기 업데이트
    });

    // 카테고리에 Day 추가 버튼
    const addDayButton = document.createElement('button');
    addDayButton.className = 'add-day-btn';
    addDayButton.textContent = '➕ Day 추가';
    addDayButton.onclick = async () => {
        const tasksInput = await showCustomModal("새로운 Day에 추가할 태스크를 쉼표(,)로 구분하여 입력하세요 (선택 사항):", 'prompt', '');
        const tasks = tasksInput ? tasksInput.split(',').map(content => ({ id: crypto.randomUUID(), content: content.trim() })).filter(t => t.content !== '') : [];
        addDayToCategory(categoryName, tasks);
    };
    categoryBox.appendChild(addDayButton);

    checklist.appendChild(categoryBox); // 카테고리 박스를 전체 체크리스트 컨테이너에 추가
  }

    // 초기 로드 시 체크리스트 데이터가 없으면 기본값 설정 (새 빈 체크리스트 생성 버튼으로 이동)
    if (checklistData.length === 0) {
        createNewEmptyChecklist(false); // 처음 로드 시 자동 생성, 확인 메시지 없이
    }
}

// 새 빈 체크리스트 생성 함수
async function createNewEmptyChecklist(showAlert = true) {
    let confirmed = true;
    if (showAlert) {
        confirmed = await showCustomModal("정말로 모든 체크리스트를 초기화하고 새 체크리스트를 만드시겠습니까?", 'confirm');
    }
    
    if (confirmed) {
        checklistData = []; // 모든 체크리스트 데이터 초기화
        checklistState = {}; // 모든 체크 상태 초기화
        localStorage.removeItem(STORAGE_KEY_APP_TITLE); // 앱 타이틀 초기화
        appTitleElement.textContent = "📅 마케팅 체크리스트"; // 기본값으로 설정
        saveState(); // 저장
        
        // 기본 빈 카테고리 추가
        const defaultCategoryName = "새로운 카테고리";
        const defaultDayNumber = 1;
        checklistData.push({ day: defaultDayNumber, category: defaultCategoryName, tasks: [{ id: crypto.randomUUID(), content: "새로운 태스크를 추가해보세요!" }], displayTitle: `📅 Day ${defaultDayNumber}` }); // Add displayTitle
        
        saveState(); // 새로운 기본 데이터 저장
        buildChecklist(); // UI 다시 그리기
        updateOverallProgress(); // 전체 진행률 업데이트
        diagnosisResult.style.display = "none"; // 진단 결과 숨김
        printResultBtn.style.display = "none"; // 진단 결과 인쇄 버튼 숨김
        checklist.scrollTo({ left: 0, behavior: 'smooth' }); // 카드 가로 스크롤 맨 앞으로
        setTimeout(() => {
          window.scrollTo({ top: 0, behavior: 'smooth' });
        }, 80);
    }
}


// '전체 체크 초기화' 버튼 클릭 이벤트
resetBtn.addEventListener("click", async () => {
  const confirmed = await showCustomModal("모든 체크 항목을 초기화 하시겠습니까?", 'confirm');
  if (confirmed) {
    checklistState = {}; // 상태 초기화
    saveState(); // 저장
    buildChecklist(); // UI 다시 그리기
    updateOverallProgress(); // 전체 진행률 업데이트
    diagnosisResult.style.display = "none"; // 진단 결과 숨김
    printResultBtn.style.display = "none"; // 진단 결과 인쇄 버튼 숨김
    checklist.scrollTo({ left: 0, behavior: 'smooth' }); // 카드 가로 스크롤 맨 앞으로

    setTimeout(() => {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }, 80);
  }
});


// '인쇄 / PDF 저장' 버튼 클릭 이벤트 (체크리스트 전체 인쇄)
printPdfBtn.addEventListener("click", () => {
  document.body.classList.remove("printing-result"); // 결과만 인쇄 모드 해제
  window.print(); // 인쇄 다이얼로그 호출
});

// '진단 결과 보기' 버튼 클릭 이벤트
showResultBtn.addEventListener("click", () => {
  const completedTasks = [];
  checklistData.forEach(({ category, day, tasks, displayTitle }) => { // displayTitle 추가
    tasks.forEach(task => { // task 객체 사용
      if (checklistState[task.id]) {
        completedTasks.push(`[${category}] ${displayTitle}: ${task.content}`); // displayTitle 사용
      }
    });
  });

  const totalTasks = checklistData.reduce((acc, day) => acc + day.tasks.length, 0);
  const doneTasks = Object.values(checklistState).filter(v => v).length;
  const percent = totalTasks ? Math.round((doneTasks / totalTasks) * 100) : 0;

  summaryText.textContent = `총 ${totalTasks}개 중 ${doneTasks}개 완료 (${percent}%)`; // 요약 텍스트 업데이트

  completedTasksList.innerHTML = ""; // 기존 목록 초기화
  if (completedTasks.length === 0) {
    completedTasksList.innerHTML = "<li>아직 완료된 항목이 없습니다.</li>";
  } else {
    completedTasks.forEach(task => {
      const li = document.createElement("li");
      li.textContent = task;
      completedTasksList.appendChild(li); // 목록에 추가
    });
  }

  diagnosisResult.style.display = "block"; // 진단 결과 표시
  printResultBtn.style.display = "inline-block"; // 진단 결과 인쇄 버튼 표시
  diagnosisResult.scrollIntoView({ behavior: "smooth" }); // 결과 영역으로 부드럽게 스크롤
});

// '진단 결과만 인쇄/PDF' 버튼 클릭 이벤트
printResultBtn.addEventListener("click", function() {
  document.body.classList.add("printing-result"); // 결과만 인쇄 모드 설정
  window.print(); // 인쇄 다이얼로그 호출
  // 인쇄가 완료되면 클래스 제거 (인쇄 후 원래 스타일로 돌아오도록)
  setTimeout(() => {
    document.body.classList.remove("printing-result");
  }, 1000);
});

// 앱 타이틀 변경 이벤트 리스너
appTitleElement.addEventListener('blur', () => {
    saveState();
});
appTitleElement.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault(); // 새 줄 방지
        appTitleElement.blur(); // 포커스 잃게 하여 저장 트리거
    }
});


// 새 빈 체크리스트 생성 버튼 이벤트 리스너
newEmptyChecklistBtn.addEventListener("click", () => createNewEmptyChecklist(true)); // 명시적으로 true 전달

// 저장 버튼 이벤트 리스너
saveAllBtn.addEventListener("click", () => {
    saveState();
    showCustomModal("현재 체크리스트 상태가 저장되었습니다.", "alert");
});


// 페이지 로드 시 체크리스트 빌드 및 진행률 업데이트
loadState(); // 저장된 데이터 및 상태 불러오기
buildChecklist();
updateOverallProgress();
// 초기 화살표 버튼 가시성 설정 및 위치 업데이트
updateArrowButtonVisibility();

//양화살표 따라오기

let currentTranslateY = 0;

function lerp(start, end, t) {
  return start * (1 - t) + end * t;
}

function update() {
  const scrollY = window.scrollY || window.pageYOffset;
  const docHeight = document.documentElement.scrollHeight - window.innerHeight;
  const scrollRatio = docHeight > 0 ? scrollY / docHeight : 0;
  const moveRange = window.innerHeight * 0.6; // 0.6~0.7 정도가 적당

  const targetTranslateY = (scrollRatio - 0.5) * moveRange;

  // 부드럽게 따라오게 보간
  currentTranslateY = lerp(currentTranslateY, targetTranslateY, 0.13);

  document.querySelectorAll('.scroll-button').forEach(btn => {
   
  });

  requestAnimationFrame(update);
}

requestAnimationFrame(update);

const currentUrl = window.location.href;
const pageTitle = document.title;


// 카카오톡 공유 (모바일에서만 동작, PC에서는 안내)
document.getElementById('btn-kakaotalk').onclick = async function(e) {
  e.preventDefault();
  const kakaoUrl = `kakao://send?text=${encodeURIComponent(pageTitle)}%0A${encodeURIComponent(currentUrl)}`;
  if (/Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) {
    window.location.href = kakaoUrl;
  } else {
    await showCustomModal('카카오톡 공유는 모바일에서만 지원됩니다.', 'alert');
  }
};

// Web Share API (지원 브라우저)
document.getElementById('btn-webshare').onclick = async function() {
  if (navigator.share) {
    navigator.share({
      title: pageTitle,
      url: currentUrl
    }).catch(() => {});
  } else {
    if (navigator.clipboard) {
      await navigator.clipboard.writeText(currentUrl);
      await showCustomModal('링크가 복사되었습니다.', 'alert');
    } else {
      await showCustomModal('아래 링크를 복사하세요', 'prompt', currentUrl);
    }
  }
};

//다운로드
document.getElementById('btn-download').onclick = function() {
  const source = document.documentElement.outerHTML;
  const blob = new Blob([source], {type: "text/html"});
  const url = URL.createObjectURL(blob);

  const anchor = document.createElement('a');
  anchor.href = url;
  anchor.download = '마케팅_30일_체크리스트.html';
  document.body.appendChild(anchor);
  anchor.click();
  document.body.removeChild(anchor);
  URL.revokeObjectURL(url);
};

</script>
</body>
</html>
